---
phase: 02-lead-capture
plan: 01
type: execute
---

<objective>
Create the lead capture form with validation for the quote request flow.

Purpose: Transform the placeholder quote page into a functional multi-step form that captures lead info and quote requirements.
Output: Working quote request form with validation, collecting name, email, phone, company, address, speed, and term.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

**Tech available:**
- shadcn/ui form components (react-hook-form + zod)
- Prisma with Lead and Quote models
- Next.js Server Actions

**Database models (from prisma/schema.prisma):**
- Lead: id, name, email, phone, company, createdAt, updatedAt
- Quote: id, leadId, streetAddress, city, state, zipCode, speed, term, status, quoteRequestId, mrc, nrc, carrierName, errorMessage, createdAt, updatedAt

**Key decisions:**
- Google-style address input on landing page links to /quote
- Lead capture is core value — collect before showing any quotes

**Form fields needed:**
- Contact: name, email, phone, company
- Location: streetAddress, city, state, zipCode
- Service: speed (dropdown), term (dropdown)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quote request form with validation</name>
  <files>src/app/quote/page.tsx, src/lib/validations/quote.ts</files>
  <action>
1. Create src/lib/validations/quote.ts with zod schema:
```typescript
import { z } from "zod"

export const quoteFormSchema = z.object({
  // Contact info
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email"),
  phone: z.string().min(10, "Please enter a valid phone number"),
  company: z.string().min(2, "Company name must be at least 2 characters"),
  // Location
  streetAddress: z.string().min(5, "Please enter a valid street address"),
  city: z.string().min(2, "Please enter a city"),
  state: z.string().min(2, "Please enter a state"),
  zipCode: z.string().min(5, "Please enter a valid zip code"),
  // Service requirements
  speed: z.string().min(1, "Please select a speed"),
  term: z.string().min(1, "Please select a contract term"),
})

export type QuoteFormValues = z.infer<typeof quoteFormSchema>
```

2. Update src/app/quote/page.tsx with a clean, single-page form:
- Use shadcn Form, FormField, FormItem, FormLabel, FormControl, FormMessage
- Contact section: name, email, phone, company (2x2 grid)
- Location section: streetAddress (full width), city/state/zip (3 columns)
- Service section: speed dropdown, term dropdown (2 columns)
- Speed options: 100 Mbps, 250 Mbps, 500 Mbps, 1 Gbps, 10 Gbps
- Term options: 12 months, 24 months, 36 months, 60 months
- Submit button: "Get My Quote"
- Use Card wrapper for clean look
- Show loading state on submit

DO NOT use multi-step wizard — keep it simple, single page form.
  </action>
  <verify>Form renders without errors, validation messages appear for invalid input</verify>
  <done>Quote form displays with all fields, validation works client-side</done>
</task>

<task type="auto">
  <name>Task 2: Create server action to submit quote request</name>
  <files>src/app/quote/actions.ts, src/app/quote/page.tsx</files>
  <action>
1. Create src/app/quote/actions.ts with server action:
```typescript
"use server"

import { db } from "@/lib/db"
import { quoteFormSchema, type QuoteFormValues } from "@/lib/validations/quote"
import { revalidatePath } from "next/cache"

export async function submitQuoteRequest(data: QuoteFormValues) {
  // Validate on server
  const validated = quoteFormSchema.safeParse(data)
  if (!validated.success) {
    return { success: false, error: "Invalid form data" }
  }

  try {
    // Create lead
    const lead = await db.lead.create({
      data: {
        name: validated.data.name,
        email: validated.data.email,
        phone: validated.data.phone,
        company: validated.data.company,
      },
    })

    // Create quote request
    const quote = await db.quote.create({
      data: {
        leadId: lead.id,
        streetAddress: validated.data.streetAddress,
        city: validated.data.city,
        state: validated.data.state,
        zipCode: validated.data.zipCode,
        speed: validated.data.speed,
        term: validated.data.term,
        status: "pending",
      },
    })

    revalidatePath("/dashboard")

    return { success: true, quoteId: quote.id, leadId: lead.id }
  } catch (error) {
    console.error("Failed to create quote request:", error)
    return { success: false, error: "Failed to submit quote request" }
  }
}
```

2. Update src/app/quote/page.tsx:
- Import and use the server action
- On success, show toast notification and redirect to a thank-you state or /dashboard
- On error, show error toast
- Add "use client" directive since form uses hooks
  </action>
  <verify>Form submission creates Lead and Quote records in database (check with `npx prisma studio`)</verify>
  <done>Quote submission creates database records, success/error feedback shown to user</done>
</task>

<task type="auto">
  <name>Task 3: Update landing page to pass address to quote form</name>
  <files>src/app/page.tsx, src/app/quote/page.tsx</files>
  <action>
1. Update landing page address input:
- Make it a real form that redirects to /quote with address as query param
- When user types address and hits enter (or clicks), go to /quote?address=...

2. Update quote form to pre-fill address from query params:
- Read searchParams for address
- If address provided, try to parse and pre-fill streetAddress field
- Focus on first empty field

This creates the "Google-style" flow: type address on home → land on form with address pre-filled.
  </action>
  <verify>Typing address on homepage and pressing enter takes user to /quote with address pre-filled</verify>
  <done>Address flows from homepage to quote form seamlessly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] Form renders with all fields and validation
- [ ] Submitting form creates Lead and Quote in database
- [ ] Address from homepage pre-fills in quote form
- [ ] Success/error toasts appear appropriately
</verification>

<success_criteria>
- Quote form fully functional with validation
- Server action creates Lead and Quote records
- Address flows from landing page to form
- User receives feedback on submission
</success_criteria>

<output>
After completion, create `.planning/phases/02-lead-capture/02-01-SUMMARY.md`
</output>
